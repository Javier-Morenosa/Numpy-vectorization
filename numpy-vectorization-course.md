# üöÄ Curso Completo: Vectorizaci√≥n con NumPy (De 0 a 100)

## üìã √çndice
1. [Introducci√≥n: ¬øQu√© es la vectorizaci√≥n?](#introducci√≥n)
2. [¬øPor qu√© es importante?](#por-qu√©-importante)
3. [Conceptos fundamentales](#conceptos-fundamentales)
4. [De bucles a vectores](#de-bucles-a-vectores)
5. [Broadcasting: La magia de NumPy](#broadcasting)
6. [T√©cnicas avanzadas](#t√©cnicas-avanzadas)
7. [Casos pr√°cticos del mundo real](#casos-pr√°cticos)
8. [Errores comunes y c√≥mo evitarlos](#errores-comunes)
9. [Proyecto final integrador](#proyecto-final)

---

## 1. Introducci√≥n: ¬øQu√© es la vectorizaci√≥n? {#introducci√≥n}

### üéØ Definici√≥n simple
La vectorizaci√≥n es **realizar operaciones sobre arrays completos en lugar de elemento por elemento**.

### üìä Ejemplo visual
```python
# SIN vectorizaci√≥n (lento) üêå
resultado = []
for i in range(len(lista)):
    resultado.append(lista[i] * 2)

# CON vectorizaci√≥n (r√°pido) ‚ö°
import numpy as np
array = np.array(lista)
resultado = array * 2
```

### üß† La met√°fora de la f√°brica
Imagina que tienes que pintar 1000 sillas:
- **Sin vectorizaci√≥n**: Pintas cada silla completamente antes de pasar a la siguiente
- **Con vectorizaci√≥n**: Aplicas una capa de pintura a TODAS las sillas al mismo tiempo

---

## 2. ¬øPor qu√© es importante? {#por-qu√©-importante}

### ‚è±Ô∏è Diferencias de velocidad reales
```python
import numpy as np
import time

# Crear datos de prueba
n = 1_000_000
lista_python = list(range(n))
array_numpy = np.arange(n)

# M√©todo tradicional con bucles
start = time.time()
resultado_bucle = []
for x in lista_python:
    resultado_bucle.append(x ** 2)
tiempo_bucle = time.time() - start

# M√©todo vectorizado
start = time.time()
resultado_vector = array_numpy ** 2
tiempo_vector = time.time() - start

print(f"Tiempo con bucle: {tiempo_bucle:.4f} segundos")
print(f"Tiempo vectorizado: {tiempo_vector:.4f} segundos")
print(f"¬°Vectorizaci√≥n es {tiempo_bucle/tiempo_vector:.1f}x m√°s r√°pida!")
```

**Resultado t√≠pico:**
```
Tiempo con bucle: 0.2500 segundos
Tiempo vectorizado: 0.0025 segundos
¬°Vectorizaci√≥n es 100.0x m√°s r√°pida!
```

### üí° Ventajas clave
1. **Velocidad**: 10-100x m√°s r√°pido
2. **C√≥digo m√°s limpio**: Menos l√≠neas, m√°s legible
3. **Menos errores**: Sin √≠ndices que gestionar
4. **Uso eficiente de memoria**: NumPy optimiza el almacenamiento

---

## 3. Conceptos fundamentales {#conceptos-fundamentales}

### üì¶ Arrays vs Listas
```python
# Lista de Python: elementos pueden ser de cualquier tipo
lista = [1, "hola", 3.14, [1,2,3]]

# Array de NumPy: todos los elementos del mismo tipo
array = np.array([1, 2, 3, 4])  # todos enteros
```

### üî¢ Tipos de datos (dtype)
```python
# NumPy elige el tipo autom√°ticamente
arr_int = np.array([1, 2, 3])          # dtype: int64
arr_float = np.array([1.0, 2.0, 3.0])  # dtype: float64

# O puedes especificarlo
arr_32 = np.array([1, 2, 3], dtype=np.float32)
```

### üìê Formas y dimensiones
```python
# Vector (1D)
vector = np.array([1, 2, 3, 4])
print(f"Forma: {vector.shape}")  # (4,)

# Matriz (2D)
matriz = np.array([[1, 2], 
                   [3, 4], 
                   [5, 6]])
print(f"Forma: {matriz.shape}")  # (3, 2)

# Tensor (3D)
tensor = np.array([[[1, 2], [3, 4]], 
                   [[5, 6], [7, 8]]])
print(f"Forma: {tensor.shape}")  # (2, 2, 2)
```

---

## 4. De bucles a vectores {#de-bucles-a-vectores}

### üîÑ Transformaci√≥n paso a paso

#### Ejemplo 1: Suma de elementos
```python
# ‚ùå Con bucles
def suma_bucle(lista1, lista2):
    resultado = []
    for i in range(len(lista1)):
        resultado.append(lista1[i] + lista2[i])
    return resultado

# ‚úÖ Vectorizado
def suma_vector(arr1, arr2):
    return arr1 + arr2

# Comparaci√≥n
a = np.random.rand(10000)
b = np.random.rand(10000)

%timeit suma_bucle(a.tolist(), b.tolist())  # ~2.5 ms
%timeit suma_vector(a, b)                    # ~10 Œºs (250x m√°s r√°pido!)
```

#### Ejemplo 2: Aplicar funci√≥n matem√°tica
```python
# ‚ùå Con bucles
def aplicar_formula_bucle(lista):
    resultado = []
    for x in lista:
        # F√≥rmula: f(x) = x¬≤ + 2x + 1
        resultado.append(x**2 + 2*x + 1)
    return resultado

# ‚úÖ Vectorizado
def aplicar_formula_vector(arr):
    return arr**2 + 2*arr + 1

# La versi√≥n vectorizada es m√°s legible Y m√°s r√°pida
```

#### Ejemplo 3: Operaciones condicionales
```python
# ‚ùå Con bucles
def filtrar_positivos_bucle(lista):
    resultado = []
    for x in lista:
        if x > 0:
            resultado.append(x)
        else:
            resultado.append(0)
    return resultado

# ‚úÖ Vectorizado
def filtrar_positivos_vector(arr):
    return np.where(arr > 0, arr, 0)

# O incluso m√°s simple:
def filtrar_positivos_vector2(arr):
    return arr * (arr > 0)
```

---

## 5. Broadcasting: La magia de NumPy {#broadcasting}

### üé® ¬øQu√© es broadcasting?
Broadcasting permite operar arrays de diferentes formas sin copiar datos.

### üìè Reglas del broadcasting
1. Los arrays se alinean por la derecha
2. Las dimensiones deben ser iguales o una debe ser 1
3. Las dimensiones faltantes se consideran 1

### üîç Ejemplos visuales

#### Broadcasting simple
```python
# Array + escalar
arr = np.array([1, 2, 3, 4])
resultado = arr + 10  # [11, 12, 13, 14]

# Lo que NumPy hace internamente:
# [1, 2, 3, 4] + 10
# [1, 2, 3, 4] + [10, 10, 10, 10]  # Broadcasting!
```

#### Broadcasting 2D
```python
# Matriz + vector (por filas)
matriz = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

vector_fila = np.array([10, 20, 30])
resultado = matriz + vector_fila
# [[11, 22, 33],
#  [14, 25, 36],
#  [17, 28, 39]]

# Matriz + vector (por columnas)
vector_columna = np.array([[100], 
                           [200], 
                           [300]])
resultado2 = matriz + vector_columna
# [[101, 102, 103],
#  [204, 205, 206],
#  [307, 308, 309]]
```

#### Ejemplo pr√°ctico: Normalizaci√≥n
```python
# Normalizar cada columna de una matriz
datos = np.random.rand(100, 3) * 100

# Media y desviaci√≥n de cada columna
media = datos.mean(axis=0)      # shape: (3,)
desviacion = datos.std(axis=0)  # shape: (3,)

# Normalizaci√≥n con broadcasting
datos_normalizados = (datos - media) / desviacion
# Broadcasting: (100,3) - (3,) ‚Üí (100,3)
```

---

## 6. T√©cnicas avanzadas {#t√©cnicas-avanzadas}

### üéØ Indexaci√≥n avanzada
```python
# Indexaci√≥n booleana
arr = np.array([1, -2, 3, -4, 5])
positivos = arr[arr > 0]  # [1, 3, 5]

# Indexaci√≥n fancy
indices = np.array([0, 2, 4])
seleccionados = arr[indices]  # [1, 3, 5]

# Asignaci√≥n condicional
arr[arr < 0] = 0  # Convierte negativos en 0
```

### üîÑ Reestructuraci√≥n eficiente
```python
# Reshape sin copiar datos
matriz = np.arange(12)
vista_3x4 = matriz.reshape(3, 4)
vista_2x6 = matriz.reshape(2, 6)

# Transpose eficiente
matriz_T = matriz.T  # Vista, no copia

# Stack y concatenate
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
vertical = np.vstack([a, b])    # [[1,2,3], [4,5,6]]
horizontal = np.hstack([a, b])  # [1,2,3,4,5,6]
```

### üí™ Funciones universales (ufuncs)
```python
# Operaciones elemento a elemento optimizadas
arr = np.linspace(0, np.pi, 1000)

# Todas estas son ufuncs (s√∫per r√°pidas)
seno = np.sin(arr)
coseno = np.cos(arr)
exponencial = np.exp(arr)
logaritmo = np.log(arr + 1)

# Combinar ufuncs
resultado = np.sqrt(np.sin(arr)**2 + np.cos(arr)**2)  # Siempre 1
```

### üßÆ √Ålgebra lineal vectorizada
```python
# Multiplicaci√≥n de matrices
A = np.random.rand(100, 50)
B = np.random.rand(50, 30)

# ‚ùå NO hagas esto
resultado_lento = np.zeros((100, 30))
for i in range(100):
    for j in range(30):
        for k in range(50):
            resultado_lento[i,j] += A[i,k] * B[k,j]

# ‚úÖ Haz esto
resultado_rapido = A @ B  # o np.dot(A, B)
```

---

## 7. Casos pr√°cticos del mundo real {#casos-pr√°cticos}

### üìä Caso 1: An√°lisis de series temporales
```python
# Datos de ventas diarias durante 1 a√±o
np.random.seed(42)
ventas = np.random.normal(1000, 200, 365) + np.sin(np.arange(365) * 2 * np.pi / 365) * 300

# Media m√≥vil de 7 d√≠as (vectorizado)
def media_movil_vectorizada(data, ventana=7):
    # Crear matriz de ventanas deslizantes
    n = len(data)
    indices = np.arange(ventana)[None, :] + np.arange(n - ventana + 1)[:, None]
    return data[indices].mean(axis=1)

media_movil = media_movil_vectorizada(ventas)

# Detectar anomal√≠as (valores > 2 desviaciones est√°ndar)
media = ventas.mean()
std = ventas.std()
anomalias = np.abs(ventas - media) > 2 * std
dias_anomalos = np.where(anomalias)[0]
```

### üñºÔ∏è Caso 2: Procesamiento de im√°genes
```python
# Simular imagen RGB
imagen = np.random.randint(0, 256, (1024, 1024, 3), dtype=np.uint8)

# Convertir a escala de grises (vectorizado)
# F√≥rmula: 0.299*R + 0.587*G + 0.114*B
pesos = np.array([0.299, 0.587, 0.114])
gris = (imagen @ pesos).astype(np.uint8)

# Aplicar filtro de brillo
brillo = 50
imagen_brillante = np.clip(imagen + brillo, 0, 255).astype(np.uint8)

# Detectar bordes (simplificado)
kernel_sobel = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
# Aqu√≠ usar√≠as scipy.signal.convolve2d, pero el concepto es vectorizaci√≥n
```

### üìà Caso 3: Machine Learning
```python
# Dataset de clasificaci√≥n
n_muestras = 10000
n_features = 20
X = np.random.randn(n_muestras, n_features)
y = (X[:, 0] + X[:, 1] * 2 - X[:, 2] * 0.5 + np.random.randn(n_muestras) * 0.1) > 0

# Normalizaci√≥n vectorizada
X_normalizado = (X - X.mean(axis=0)) / X.std(axis=0)

# C√°lculo de distancias (para k-NN)
def distancias_euclideas_vectorizadas(X1, X2):
    # X1: (n1, d), X2: (n2, d)
    # Resultado: (n1, n2) matriz de distancias
    X1_cuadrado = np.sum(X1**2, axis=1)[:, np.newaxis]
    X2_cuadrado = np.sum(X2**2, axis=1)[np.newaxis, :]
    X1_X2 = X1 @ X2.T
    distancias = np.sqrt(X1_cuadrado + X2_cuadrado - 2 * X1_X2)
    return distancias

# Calcular todas las distancias de una vez
distancias = distancias_euclideas_vectorizadas(X_normalizado[:100], X_normalizado[:100])
```

---

## 8. Errores comunes y c√≥mo evitarlos {#errores-comunes}

### ‚ùå Error 1: Modificar vistas sin darse cuenta
```python
# PROBLEMA
arr = np.arange(10)
vista = arr[5:]
vista[0] = 999  # ¬°Esto modifica arr tambi√©n!

# SOLUCI√ìN
copia = arr[5:].copy()
copia[0] = 999  # arr no se modifica
```

### ‚ùå Error 2: Broadcasting no intencional
```python
# PROBLEMA
a = np.array([[1, 2, 3]])      # shape: (1, 3)
b = np.array([[1], [2], [3]])  # shape: (3, 1)
resultado = a + b  # shape: (3, 3) - ¬øEra esto lo que quer√≠as?

# SOLUCI√ìN: Verificar shapes
print(f"a.shape: {a.shape}, b.shape: {b.shape}")
# Si quieres suma elemento a elemento, aseg√∫rate de que las shapes coincidan
```

### ‚ùå Error 3: Uso ineficiente de memoria
```python
# PROBLEMA
matriz_grande = np.random.rand(10000, 10000)  # ~763 MB
matriz_copia = matriz_grande * 2  # Otros ~763 MB

# SOLUCI√ìN: Operaciones in-place cuando sea posible
matriz_grande *= 2  # Modifica en el lugar, sin copia extra

# O usar vistas
matriz_vista = matriz_grande[::2, ::2]  # Vista, no copia
```

### ‚ùå Error 4: No aprovechar funciones built-in
```python
# PROBLEMA
def mi_suma(arr):
    total = 0
    for x in arr:
        total += x
    return total

# SOLUCI√ìN
total = arr.sum()  # Mucho m√°s r√°pido

# Otras funciones √∫tiles:
# arr.mean(), arr.std(), arr.min(), arr.max()
# arr.argmin(), arr.argmax(), arr.argsort()
```

---

## 9. Proyecto final integrador {#proyecto-final}

### üéØ Proyecto: Sistema de recomendaci√≥n vectorizado

Vamos a construir un sistema de recomendaci√≥n simple pero eficiente usando solo operaciones vectorizadas.

```python
import numpy as np

class SistemaRecomendacion:
    """Sistema de recomendaci√≥n basado en similitud coseno"""
    
    def __init__(self, n_usuarios=1000, n_items=500, n_features=20):
        # Simular datos: matriz de caracter√≠sticas de items
        self.items_features = np.random.randn(n_items, n_features)
        
        # Simular preferencias de usuarios (sparse)
        self.ratings = np.zeros((n_usuarios, n_items))
        # Cada usuario califica ~50 items aleatorios
        for u in range(n_usuarios):
            items_calificados = np.random.choice(n_items, 50, replace=False)
            self.ratings[u, items_calificados] = np.random.randint(1, 6, 50)
    
    def normalizar_features(self):
        """Normaliza las caracter√≠sticas de los items"""
        # Vectorizado: normalizar cada columna
        self.items_features = (self.items_features - self.items_features.mean(axis=0)) / self.items_features.std(axis=0)
    
    def calcular_similitud_items(self):
        """Calcula matriz de similitud entre todos los items"""
        # Normalizar vectores para similitud coseno
        normas = np.linalg.norm(self.items_features, axis=1, keepdims=True)
        items_norm = self.items_features / normas
        
        # Producto matricial = similitud coseno
        self.similitud = items_norm @ items_norm.T
        
        # Poner diagonal en 0 (un item no es similar a s√≠ mismo para recomendaciones)
        np.fill_diagonal(self.similitud, 0)
    
    def predecir_ratings(self, usuario_id, n_vecinos=20):
        """Predice ratings para items no calificados"""
        # Items que el usuario ya calific√≥
        items_calificados = self.ratings[usuario_id] > 0
        
        # Para cada item no calificado, usar vecinos m√°s similares
        predicciones = np.zeros(self.ratings.shape[1])
        
        for item in range(self.ratings.shape[1]):
            if items_calificados[item]:
                predicciones[item] = self.ratings[usuario_id, item]
            else:
                # Encontrar k vecinos m√°s similares que el usuario s√≠ calific√≥
                similitudes = self.similitud[item].copy()
                similitudes[~items_calificados] = -1  # Ignorar items no calificados
                
                # √çndices de los k m√°s similares
                vecinos_idx = np.argpartition(similitudes, -n_vecinos)[-n_vecinos:]
                vecinos_idx = vecinos_idx[similitudes[vecinos_idx] > 0]
                
                if len(vecinos_idx) > 0:
                    # Predicci√≥n ponderada por similitud
                    pesos = similitudes[vecinos_idx]
                    ratings_vecinos = self.ratings[usuario_id, vecinos_idx]
                    predicciones[item] = np.average(ratings_vecinos, weights=pesos)
        
        return predicciones
    
    def recomendar_items(self, usuario_id, n_recomendaciones=10):
        """Recomienda los mejores items para un usuario"""
        predicciones = self.predecir_ratings(usuario_id)
        
        # Excluir items ya calificados
        items_no_calificados = self.ratings[usuario_id] == 0
        predicciones[~items_no_calificados] = -1
        
        # Top N items
        top_items = np.argpartition(predicciones, -n_recomendaciones)[-n_recomendaciones:]
        top_items = top_items[np.argsort(predicciones[top_items])[::-1]]
        
        return top_items, predicciones[top_items]
    
    def evaluar_sistema(self, test_size=0.2):
        """Eval√∫a el sistema con validaci√≥n cruzada"""
        # Separar datos de prueba
        mask_test = np.random.rand(*self.ratings.shape) < test_size
        mask_test &= self.ratings > 0  # Solo items calificados
        
        ratings_train = self.ratings.copy()
        ratings_train[mask_test] = 0
        
        # Guardar ratings originales y usar ratings_train
        ratings_original = self.ratings.copy()
        self.ratings = ratings_train
        
        # Calcular similitudes con datos de entrenamiento
        self.calcular_similitud_items()
        
        # Predecir y calcular error
        errores = []
        for u in range(self.ratings.shape[0]):
            if np.any(mask_test[u]):
                predicciones = self.predecir_ratings(u)
                items_test = np.where(mask_test[u])[0]
                error = np.abs(predicciones[items_test] - ratings_original[u, items_test])
                errores.extend(error)
        
        # Restaurar ratings originales
        self.ratings = ratings_original
        
        return np.mean(errores), np.std(errores)

# Usar el sistema
sistema = SistemaRecomendacion()
sistema.normalizar_features()
sistema.calcular_similitud_items()

# Hacer recomendaciones para el usuario 0
items_recomendados, scores = sistema.recomendar_items(0)
print(f"Items recomendados: {items_recomendados}")
print(f"Scores predichos: {scores}")

# Evaluar el sistema
mae, std = sistema.evaluar_sistema()
print(f"Error absoluto medio: {mae:.3f} ¬± {std:.3f}")
```

### üéâ ¬°Felicitaciones!

Has completado el curso de vectorizaci√≥n con NumPy. Ahora puedes:

1. ‚úÖ Identificar oportunidades de vectorizaci√≥n en tu c√≥digo
2. ‚úÖ Transformar bucles lentos en operaciones vectorizadas r√°pidas
3. ‚úÖ Usar broadcasting para operaciones complejas
4. ‚úÖ Aplicar t√©cnicas avanzadas de NumPy
5. ‚úÖ Evitar errores comunes
6. ‚úÖ Implementar algoritmos complejos de forma eficiente

### üìö Recursos para seguir aprendiendo

1. **Documentaci√≥n oficial de NumPy**: https://numpy.org/doc/stable/
2. **NumPy para MATLAB users**: Si vienes de MATLAB
3. **From Python to NumPy** de Nicolas P. Rougier
4. **100 NumPy exercises**: Para practicar

### üí° Consejo final

> "La vectorizaci√≥n no es solo sobre velocidad, es sobre pensar en t√©rminos de operaciones sobre conjuntos de datos completos en lugar de elementos individuales. Este cambio de mentalidad te har√° un mejor programador cient√≠fico."

---

## üèÜ Certificado de completaci√≥n

**¬°Felicidades!** Has dominado los conceptos de vectorizaci√≥n con NumPy. Ahora tienes las herramientas para escribir c√≥digo Python que es:

- ‚ö° 10-100x m√°s r√°pido
- üìñ M√°s legible y mantenible
- üéØ M√°s preciso y menos propenso a errores
- üí™ Capaz de manejar grandes vol√∫menes de datos

¬°Ahora ve y vectoriza el mundo! üöÄ